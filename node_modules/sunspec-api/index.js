"use strict";

var SunSpec = require('./lib/core.js');

var debugOn = false;
var locale = Homey.manager('i18n').getLanguage();
var inverters = {};
var sensors = {};
var sensorQueue = {};

// Debug logging
function debug(text) {
	if (debugOn) {
		var now = new Date();
		if (typeof text == 'object') {
			var output = '';
			for (var property in text) {
			  output += property + ': ' + text[property]+'; ';
			};
			text = output;
		}
		var time = now.toTimeString().replace(/.*(\d{2}:\d{2}:\d{2}).*/, "$1");
		var ms = ('00' + now.getMilliseconds()).slice(-3);
		Homey.log(time + '.' + ms + ' ' + text);
	}
}

var self = module.exports = {
	// debug function
	debug: debug,
	
	// Add a new inverter or search for one
	addInverter: function(driver, device, settings) {
		var id = device == null ? settings.ip + ':' + settings.port : device.id;
		if (inverters[id] == null) {
			var sunspec = new SunSpec(settings, debug);
			if (device != null) { // ID is correct
				inverters[id] = sunspec;
				sensors[id] = [];
				self.addInverterActions(driver, device);
			} else {
				// Add event handlers
				sunspec.events.on('found', function(data) {
					if (data.found && data.id != null) {
						if (inverters[data.id] == null) {
							data.device = {
								name: data.name,
								data: {	id: data.id },
								settings: settings
							}
							inverters[data.id] = sunspec;
							sensors[data.id] = [];
						} else {
							// Inverter already present
							data.found = false;
						}
					}
					if (!data.found) {
						sunspec.closeConnection();
					}
					Homey.emit('found', data);
				});
			}
		} else {
			debug('Error: inverter ' + id + ' already present.');
			Homey.emit('found', { found: false });
		}
	},
	
	// Add inverter actions & child device actions
	addInverterActions: function(driver, device) {
		var id = device.id;
		inverters[id].events.on('measured', function(value) {
			if (inverters[id].interval == 0) { // external trigger mode
				debug('Sending value to DSMR');
				Homey.manager('api').put('/app/nl.dsmr.p1/receive/', { id: id, value: value, err: null }, function(err, result) {
					debug('Value sent to DSMR ' + err + ' : ' + result);
				});
			}
		});
		inverters[id].events.on('INV.W', function(newVal) {
			driver.realtime(device, 'measure_power', newVal, function(err, success) {
				debug('Real-time inverter watt update: ' + (err ? err : 'OK'));
			});
		});
		inverters[id].events.on('INV.WH', function(newVal) {
			driver.realtime(device, 'meter_power', newVal / 1000, function(err, success) {
				debug('Real-time inverter kwh update: ' + (err ? err : 'OK'));
			});
		});
		inverters[id].events.on('INV.TmpSnk', function(newVal) {
			driver.realtime(device, 'measure_temperature', newVal, function(err, success) {
				debug('Real-time inverter temp. update: ' + (err ? err : 'OK'));
			});
		});
		// Add sensors in the queue (if any)
		if (sensorQueue[id] != null) {
			for (var i = 0; i < sensorQueue[id].length; i++) {
				var sensor = sensorQueue[id][i];
				self.addSensor(sensor.driver, sensor.device);
				sensor.driver.setAvailable(sensor.device);
			}
		}
		// Register inverter as producer with DSMR
		if (inverters[id].interval == 0) { // external trigger mode
			debug('Registering inverter with DSMR');
			Homey.manager('api').put('/app/nl.dsmr.p1/register/', { id: id, callback: '/app/org.sunspec/read/' }, function(err, result) {
				debug('Registration ' + err + ' : ' + result);
			});
		}
	},
	
	// Remove an inverter
	deleteInverter: function(id) {
		if (inverters[id] != null) {
			inverters[id].closeConnection();
			// mark all sensors as unavailable
			for (var i = 0; i < sensors[id].length; i++) {
				sensors[id][i].driver.setUnavailable(sensors[id][i].device, __('no_inverter'));
			}
			delete inverters[id];
			delete sensors[id];
		} else {
			debug('Error: meter ' + id + ' not present.');
		}
	},
	
	// Read a value
	getValue: function(id, inverter, callback) {
		var val = inverters[inverter] != null ? inverters[inverter].values[id] : null;
		var err = inverters[inverter] == null ? 'Invalid inverter' : null;
		callback(err, val);
	},
	
	// Send request for values
	pollValues: function(id) {
		inverters[id].pollModBus();
	}
}