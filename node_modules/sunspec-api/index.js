"use strict";

const sun = require('./lib/sunspec.js'),
	modbus =  require('./lib/modbus.js'),
	net = require('net'),
	Events = require('events');

// Main constructor
class SunSpec extends Events {

	constructor(ip, port, mbId, mbBase, debug) {
		super();
		this.id = ip + ':' + port;
		this.settings = {
			ip: ip,
			port: port,
			mbId: mbId,
			mbBase: mbBase
		}
		this.debug = debug;
		this.client;
		this.found = false;
		// Message handling
		this.msgModBus = [];
		this.msgLen = 0;
		this.modBusScan = true;
		this.modBusScanIdx = 0;
		this.lastResponse = 0;
		this.responseQueue = [];
		this.sendQueue = [];
		this.timer;
		this.reconnectTimer;
		//- MESSAGES //-
		this.sendMsg = {
			MSG_SUNSPEC : { addr: 1, len: 2, resp: "SunS" },
			MSG_SCAN    : { addr: 3, len: 2 },
			MSG_COMMON  : { addr: 3, len: 56 },
			MSG_INVERTER: {},
			MSG_METER   : {}
		};
		this.block = {};
		// Received values
		this.values = new Map();
		// Event to communicate ID and name one common block has been read
		this.on('COM.SN', () => {
			this.emit('found', {
				found: true,
				id: this.values.get('COM.SN'),
				name: this.values.get('COM.Mn') + ' ' + this.values.get('COM.Md'),
				show: [ // TODO: support locales
					{ val: this.values.get('COM.Mn'), name: 'Manufacturer' },
					{ val: this.values.get('COM.Md'), name: 'Model' },
					{ val: this.values.get('COM.SN'), name: 'Serial number' },
					{ val: this.values.get('COM.Ver'), name: 'Version' }
				]
			});
		});
		this.on('found', data => {
			this.found = data.found;
		})
		// Start communication
		this.openConnection();
	}

	// Open the connection to this SunSpec meter
	openConnection() {
		let ip = this.settings.ip;
		let port = this.settings.port;
		this.debug('Opening connection on ' + this.id + ' ModBus ID ' + this.settings.mbId + ', base ' + this.settings.mbBase);
		// Set up network communication
		this.client = new net.Socket();
		this.client.setTimeout(60000); // expect traffic once a minute
		// Register main response handler
		this.client.on('data', (data) => {
			//clearTimeout(waitTimer);
			this.processData(data);
		});
		// Error handler
		this.client.on('error', (err) => {
			this.debug(err);
			if (!this.found) {
				//clearTimeout(waitTimer);
				this.closeConnection();
			}
		});
		// Timeout handler
		this.client.on('timeout', () => {
			this.debug('Connecion timed out.');
			this.closeConnection();
		});
		// Handle closed connections, try to re-open it
		this.client.on('close', () => {
			this.debug('Connecion closed (found = ' + this.found + ')');
			if (this.found && this.reconnectTimer === undefined) {
				// Connection dropped, try to re-connect every minute
				this.reconnectTimer = setInterval(() => {
					this.debug('Re-connecting to', ip + ':' + port);
					this.openConnection(ip, port);
				}, 60000);
			}
		});
		this.client.connect(port, ip, () => {
			this.debug('Connected to', this.id);
			// Kill the re-try timer
			clearTimeout(this.reconnectTimer);
			this.reconnectTimer = undefined;
			// Search for the SunSpec Inverter
			this.sendRequest('MSG_SUNSPEC');
		});
	}

	// Close the connection to this SunSpec meter
	closeConnection() {
		clearTimeout(this.timer);
		this.found = false;
		this.client.destroy();
	}

	pollModBus() {
		// send ModBus message(s) that need polling
		for (let key in this.sendMsg) {
			let val = this.sendMsg[key];
			if (val.poll != null && val.poll == true) {
				this.debug("Poll request for " + key + " of length " + this.sendMsg[key].len);
				this.sendRequest(key);
			}
		}
	}

	sendRequest(id) {
		this.debug('sendRequest', id);
		this.sendQueue.push(id);
		// Only send a new message if we are not expecting a response
		if (this.responseQueue.length == 0) {
			id = this.sendQueue.shift();
			let msg = this.sendMsg[id];
			if (msg != null) {
				let req = new Buffer(modbus.makeRequest(this.settings.mbId, 0x03, this.settings.mbBase + msg.addr, msg.len));
				this.responseQueue.push(id);
				this.client.write(req);
			} else {
				this.debug("Invalid ID: " + id);
			}
		}
	}

	processData(data) {
		let now = new Date();
		if (now - this.lastResponse < 2 && this.msgModBus.concat) {
			this.msgModBus = this.msgModBus.concat(data);
		} else {
			// New message
			this.msgModBus = data;
		}
		this.lastResponse = now;
		if (this.msgModBus.length >= 3) {
			this.msgLen = this.msgModBus[2];
			this.debug("Receiving response with length " + this.msgLen)
		}
		if (this.msgModBus.length == this.msgLen + 5) {
			// Message complete, check CRC
			//let str = sunCmdToString(this.msgModBus);
			//this.debug("Incoming response = " + str);
			let crcCalc = modbus.calcCRC(this.msgModBus.slice(0, -2));
			let crcRead = this.msgModBus[this.msgModBus.length - 2] + 0x100 * this.msgModBus[this.msgModBus.length - 1];
			if (crcCalc != crcRead) {
				this.debug("CRC mismatch: calc " + crcCalc.toString(16) + ", read " + crcRead.toString(16));
			} else if (this.responseQueue.length > 0) { // only process data if we are expecting a response
				this.debug("Queue length is now " + this.responseQueue.length + "; first message is " + this.responseQueue[0]);
				let id = this.responseQueue.shift();
				let base = this.sendMsg[id].addr;
				let len = this.sendMsg[id].len;
				let resp = this.sendMsg[id].resp;
				if (this.msgLen == len * 2) {
					let did = ('000' + sun.decode.value("uint16", this.msgModBus.slice(3, 5))).slice(-3);
					if (this.modBusScan == true) {
						if (resp != null) {
							if (resp == this.msgModBus.slice(3, 3 + resp.length).toString()) {
								this.debug("Received response as expected");
								if (id == "MSG_SUNSPEC") {
									// Start SunSpec scan
									this.emit('found', { found: true });
									this.sendRequest("MSG_SCAN");
									this.modBusScanIdx = 3;
								}
							} else {
								this.debug("Response NOT as expected");
								if (id == "MSG_SUNSPEC") {
									this.emit('found', { found: false });
								}
							}
						} else { // check what block the scan has found
							let len = sun.decode.value("uint16", this.msgModBus.slice(5, 7));
							if (did == '65535' || len == 0) { // should be and, but or is safer
								// Found end block
								this.debug("Found end block");
								this.modBusScan = false;
								this.sendMsg.MSG_SCAN.addr = 3;
								this.sendRequest("MSG_COMMON");
							} else {
								if (sun.map.DID[did] != null) {
									this.debug("Found block: " + sun.map.DID[did].txt);
									if (sun.map.DID[did].model != null) {
										if (this.block[did] == null) {
											this.debug("Adding block of len " + len + " and with offset " + this.modBusScanIdx);
											this.block[did] = { len: len, offset: this.modBusScanIdx, model: sun.map.DID[did].model };
											this.sendMsg[sun.map.DID[did].msg] = {
												addr: this.modBusScanIdx,
												len: len,
												poll: sun.map.DID[did].poll
											};
										} else {
											this.debug("Error: already found " + sun.map.DID[did].txt + " - ignoring block with offset " + this.modBusScanIdx);
										}
									} else {
										this.debug("Found block with unknown DID: " + did.toString(16));
									}
								}
								this.modBusScanIdx += len + 2;
								this.sendMsg.MSG_SCAN.addr = this.modBusScanIdx;
								this.sendRequest("MSG_SCAN");
							}
						}
					} else { // not scanning / normal mode
						if (sun.map.DID[did] != null && sun.map.DID[did].model != null) {
							// Process model block values
							let model = sun.map.DID[did].model;
							this.debug("Starting decode of Model " + did);
							let modelValues = sun.decode.model(model, this.msgModBus.slice(3));
							// Update our variables
							for (let key in modelValues) {
								let elem = modelValues[key];
								let value = elem.val;
								if (value != null) {
									// We have a valid value in memory
									if (elem.sf != null) {
										let scaleFactor = modelValues[sun.map[model].modelName + '.' + elem.sf].val;
										value = sun.decode.applyScaleFactor(value, scaleFactor);
									}
									if (elem.factor != null) {
										// Apply factor to value
										value *= elem.factor;
									} else if (elem.tab != null) {
										// Enumerated values
										value = elem.tab[value].txt;
									}
									if (this.values.get(key) != value) {
										this.values.set(key, value);
										this.debug(key + ": " + value);
										this.emit(key, value);
									}
								}
							}
							// Always emit 'measured' event with power production value for an inverter.
							// This is used by DSMR.
							if (model == 'inverterModel') {
								this.emit('measured', this.values.get('INV.W'));
							}
						}
					}
				} else {
					this.debug("Discarding message with unexpected length");
					// restore the response queue
					this.responseQueue.push(id);
				}
			} else {
				this.debug("Discarding unexpected message");
			}
			this.msgModBus = [];
		}
		// Check the queue if we need to send another message
		if (this.sendQueue.length > 0) {
			this.sendRequest(this.sendQueue.shift());
		}
	}

	// Return a text string with the state of the inverter
	getStatus() {
		let value = this.values.get('INV.St');
		let result = value ? sun.map.status[value].txt : 'Unknown';
		return result;
	}

	// Return all values we have read and stored
	getValues() {
		let result = Object.assign({}, ...[...this.values.entries()].map(([k, v]) => ({[k]: v})));
		return result;
	}

}

module.exports = SunSpec;
