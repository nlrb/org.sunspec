"use strict";

var sun = require('./sunspec.js'),
	modbus =  require('./modbus.js'),
	net = require('net'),
	event = require('events');


// Update a variable only if the value changes
function updateValue(state, what, newVal) {
	var curVal = state.values[what];
	var changed = curVal == null || (newVal instanceof Date ? newVal.getTime() !== curVal.getTime() : newVal != curVal);
	if (changed) {
		state.debug(what + ': was ' + curVal + ' now ' + newVal);
		state.values[what] = newVal;
		state.events.emit(what, newVal);
		return true;
	} else {
		return false;
	}
}
	
// Main constructor
function SunSpec(settings, debug) {

	var self = this;
	this.id = settings.ip + ':' + settings.port;
	this.idModBus = 1;
	this.baseModBus = 40000;
	this.devSettings = settings;
	this.debug = function(text) { debug('[' + self.id + '] ' + text); };
	this.client;
	this.found = false;
	// Event handling
	this.events = new event.EventEmitter();
	// Message handling
	this.msgModBus = [];
	this.msgLen = 0;
	this.modBusScan = true;
	this.modBusScanIdx = 0;
	this.lastResponse = 0;
	this.responseQueue = [];
	this.sendQueue = [];
	this.timer;
	this.interval = 10;
	//- MESSAGES //-
	this.sendMsg = {
		MSG_SUNSPEC : { addr: 1, len: 2, resp: "SunS" },
		MSG_SCAN    : { addr: 3, len: 2 },
		MSG_COMMON  : { addr: 3, len: 56 },
		MSG_INVERTER: {},
		MSG_METER   : {} 
	};
	this.block = {};
	// Received values
	this.values = {};
	// Event to communicate ID and name one common block has been read
	self.events.on('COM.SN', function() {
		self.events.emit('found', { 
			found: true,
			id: self.values['COM.SN'],
			name: self.values['COM.Mn'] + ' ' + self.values['COM.Md'],
			show: [ // TODO: support locales
				{ val: self.values['COM.Mn'], name: 'Manufacturer' },
				{ val: self.values['COM.Md'], name: 'Model' },
				{ val: self.values['COM.SN'], name: 'Serial number' },
				{ val: self.values['COM.Ver'], name: 'Version' }
			]
		});
	});
	// Start communication
	this.openConnection(settings.ip, settings.port);
}

// Open the connection to this SunSpec meter
SunSpec.prototype.openConnection = function(ip, port) {
	var self = this;
	
	// Set up network communication
	this.client = new net.Socket();
	this.client.setTimeout(60000); // expect traffic once a minute
	// Register main response handler
	this.client.on('data', function(data) {
		//clearTimeout(waitTimer);
		self.processData(data);
	});
	// Error handler
	this.client.on('error', function(err) {
		self.debug(err);
		if (!self.found) {
			//clearTimeout(waitTimer);
			self.closeConnection();
		}
	});
	// Timeout handler
	this.client.on('timeout', function() {
		self.debug('Connecion timed out.');
		self.closeConnection();
	});
	// Handle closed connections, try to re-open it
	this.client.on('close', function() {
		self.debug('Connecion closed (found = ' + self.found + ')');
		if (self.found) {
			// Connection dropped, try to re-connect
			
		}
	});
	this.client.connect(port, ip, function() {
		self.debug('Connected to ' + self.id);
		// Kill the re-try timer
		//clearTimeout(reconnectTimer);
		// Search for the SunSpec Inverter
		//clearTimeout(waitTimer);
		self.sendRequest('MSG_SUNSPEC');
	});
}

// Close the connection to this SunSpec meter
SunSpec.prototype.closeConnection = function() {
	this.client.destroy();
}

SunSpec.prototype.pollModBus = function() {
	// send ModBus message(s) that need polling
	for (var key in this.sendMsg) {
		var val = this.sendMsg[key];
		if (val.poll != null && val.poll == true) {
			this.debug("Poll request for " + key + " of length " + this.sendMsg[key].len);
			this.sendRequest(key);
		}
	}
}

SunSpec.prototype.sendRequest = function(id) {
	this.debug('sendRequest ' + id);
	this.sendQueue.push(id);
	// Only send a new message if we are not expecting a response
	if (this.responseQueue.length == 0) {
		id = this.sendQueue.shift();
		var msg = this.sendMsg[id];
		if (msg != null) {
			var req = new Buffer(modbus.makeRequest(this.idModBus, 0x03, this.baseModBus + msg.addr, msg.len));
			this.responseQueue.push(id);
			this.client.write(req);
		} else {
			this.debug("Invalid ID: " + id);
		}
	}
}

SunSpec.prototype.processData = function(data) {
	var now = new Date();
	if (now - this.lastResponse < 2) {
		this.msgModBus = this.msgModBus.concat(data);
	} else {
		// New message
		this.msgModBus = data;
	}
	this.lastResponse = now;
	if (this.msgModBus.length >= 3) {
		this.msgLen = this.msgModBus[2];
		this.debug("Receiving response with length " + this.msgLen)
	}
	if (this.msgModBus.length == this.msgLen + 5) {
		// Message complete, check CRC
		//var str = sunCmdToString(this.msgModBus);
		//this.debug("Incoming response = " + str);
		var crcCalc = modbus.calcCRC(this.msgModBus.slice(0, -2));
		var crcRead = this.msgModBus[this.msgModBus.length - 2] + 0x100 * this.msgModBus[this.msgModBus.length - 1];
		if (crcCalc != crcRead) {
			this.debug("CRC mismatch: calc " + crcCalc.toString(16) + ", read " + crcRead.toString(16));
		} else if (this.responseQueue.length > 0) { // only process data if we are expecting a response
			this.debug("Queue length is now " + this.responseQueue.length + "; first message is " + this.responseQueue[0]);
			var id = this.responseQueue.shift();
			var base = this.sendMsg[id].addr;
			var len = this.sendMsg[id].len;
			var resp = this.sendMsg[id].resp;
			if (this.msgLen == len * 2) {
				var did = ('000' + sun.decode.value("uint16", this.msgModBus.slice(3, 5))).slice(-3);
				if (this.modBusScan == true) {
					if (resp != null) {
						if (resp == this.msgModBus.slice(3, 3 + resp.length).toString()) {
							this.debug("Received response as expected");
							if (id == "MSG_SUNSPEC") {
								// Start SunSpec scan
								this.events.emit('found', { found: true });
								this.sendRequest("MSG_SCAN");
								this.modBusScanIdx = 3;
							}
						} else {
							this.debug("Response NOT as expected");
							if (id == "MSG_SUNSPEC") {
								this.events.emit('found', { found: false });
							}
						}
					} else { // check what block the scan has found
						var len = sun.decode.value("uint16", this.msgModBus.slice(5, 7));
						if (did == '65535' || len == 0) { // should be and, but or is safer
							// Found end block
							this.debug("Found end block");
							this.modBusScan = false;
							this.sendMsg.MSG_SCAN.addr = 3;
							this.sendRequest("MSG_COMMON");
							// Set up timer
							if (this.interval > 0) {
								var self = this;
								this.timer = setInterval(function() { self.pollModBus() }, 1000 * this.interval);
							}
						} else {
							if (sun.map.DID[did] != null) {
								this.debug("Found block: " + sun.map.DID[did].txt);
								if (sun.map.DID[did].model != null) {
									if (this.block[did] == null) {
										this.debug("Adding block of len " + len + " and with offset " + this.modBusScanIdx);
										this.block[did] = { len: len, offset: this.modBusScanIdx, model: sun.map.DID[did].model };
										this.sendMsg[sun.map.DID[did].msg] = {
											addr: this.modBusScanIdx,
											len: len,
											poll: sun.map.DID[did].poll
										};
									} else {
										this.debug("Error: already found " + sun.map.DID[did].txt + " - ignoring block with offset " + this.modBusScanIdx);
									}
								} else {
									this.debug("Found block with unknown DID: " + did.toString(16));
								}
							}
							this.modBusScanIdx += len + 2;
							this.sendMsg.MSG_SCAN.addr = this.modBusScanIdx;
							this.sendRequest("MSG_SCAN");
						}
					}
				} else { // not scanning / normal mode
					if (sun.map.DID[did] != null && sun.map.DID[did].model != null) {
						// Process model block values
						var model = sun.map.DID[did].model;
						this.debug("Starting decode of Model " + did);
						var modelValues = sun.decode.model(model, this.msgModBus.slice(3));
						// Update our variables
						for (var key in modelValues) {
							var elem = modelValues[key];
							var value = elem.val;
							if (value != null) {
								// We have a valid value in memory
								if (elem.sf != null) {
									var scaleFactor = modelValues[sun.map[model].modelName + '.' + elem.sf].val;
									value = sun.decode.applyScaleFactor(value, scaleFactor);
								}
								if (elem.factor != null) {
									// Apply factor to value
									value *= elem.factor;
								} else if (elem.tab != null) {
									// Enumerated values
									value = elem.tab[value].txt;
								}
								if (this.values[key] != value) {
									this.values[key] = value;
									this.debug(key + ": " + value);
									this.events.emit(key, value);
								}
							}
						}
					}
				}
			} else {
				this.debug("Discarding message with unexpected length");
				// restore the response queue
				this.responseQueue.push(id);
			}
		} else {
			this.debug("Discarding unexpected message");
		}
		this.msgModBus = [];
	}
	// Check the queue if we need to send another message
	if (this.sendQueue.length > 0) {
		this.sendRequest(this.sendQueue.shift());
	}
}

module.exports = SunSpec;